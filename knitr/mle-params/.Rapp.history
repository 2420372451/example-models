prog <- "data { int N; real x[N]; } parameters { real<lower=0> mu; real<lower=0> sigma; } model { x ~ normal(mu,sigma); }"
N <- 100
x <- rnorm(N, 5.5, 0.5)
fit <- stan(model_code=prog, data=c("N", "x"))
library(rstan)
help(stan)
library(rstan)
help(sampling)
model <- "data { real y[3]; } parameters { real mu; } model { y ~ normal(mu, 1); }"
compiled_model <- stan_model(model_code=model)
inits <- function() { return(list(y=c(1,2,3)))}
inits <- function() { return(list(mu=3)); }
inits()
fit <- sampling(compiled_model, data=c(1,2,3), init=inits)
fit <- sampling(compiled_model, data=list(y=c(1,2,3)), init=inits)
list(N=10000)
library('rstan')
code1 <- '#
    data {#
      int N;#
    }#
    parameters {#
      vector[N] p;#
    }#
    model {#
      p ~ normal(0, 1);#
    }#
'#
#
library(rstan)#
sm <- stan_model(model_code = code1)#
#
## ok#
system.time(sampling(sm, data = list(N = 10000), iter = 10))#
#
## really slow!#
system.time(sampling(sm, data = list(N = 100000), iter = 10))
help(stan)
library(rstan)
help(testify)
quit()
model <- "data { int N; real y[N]; } parameters { real mu; } model { y ~ normal(mu, 1); }"
N <- 1
y <- array(c(1), c(1))
y
library(rstan)
fit <- stan(model_code=model, data=list(N=N, y=y))
mu_post <- extract(fit)$mu
hist(mu_post)
sum(mu_post > 0) / length(mu_post)
y <- rpois(100,10)
hist(y)
seq(0.5,19.5,1)
hist(y, breaks=seq(0.5, 19.5, 1)
)
library(ggplot2)
df = data.frame(y)
qplot(y, data=df, geom="histogram")
library(rstan)
model <- "parameters { real mu; } model { mu ~ normal(0, 1); }"
fit <- stan(model_code=model)
install.packages("rstan", repos = "http://cran.rstudio.com", #
                 dependencies = TRUE)
quit()
model <- "parameters { real mu; } model { mu ~ normal(0, 1); }"
library(rstan)
fit <- stan(model_code=model)
load("/Users/carp/Library/Containers/com.apple.mail/Data/Library/Mail Downloads/8D3068C4-B018-402C-94F2-F5A2D61B6A35/stanmodel.rda")
26629.43/3
y <- rbinom(1000, 28, 0.056)
hist(y)
summary(y / 1000)
summary(y / 28)
y <- rbinom(1000, 10, 0.5)
summary(y)
255 * 280 * 1000
help(pgamma)
help(pnorm)
library(rstan)
model <- "#
// Malingering, with Individual Differences#
data {#
int<lower=1> n;#
int<lower=1> p;#
int<lower=0,upper=n> k[p];#
}#
parameters {#
real<lower=0,upper=1> phi;#
real<lower=0,upper=1> mubon;#
real<lower=0> mudiff;#
real<lower=40,upper=800> lambdabon;#
real<lower=4,upper=100> lambdamal;#
matrix<lower=0,upper=1>[p,2] theta;#
}#
transformed parameters {#
vector[2] lp_parts[p];#
vector<lower=0>[2] alpha;#
vector<lower=0>[2] beta;#
real<lower=0,upper=1> mumal;#
// Additivity on Logit Scale#
mumal <- inv_logit(logit(mubon) - mudiff);#
// Transformation to Group Mean and Precision#
alpha[1] <- mubon * lambdabon;#
beta[1] <- lambdabon * (1 - mubon);#
alpha[2] <- mumal * lambdamal;#
beta[2] <- lambdamal * (1 - mumal);#
// Data are Binomial with Rate Given by#
// Each Personâ€™s Group Assignment#
for (i in 1:p) {#
lp_parts[i,1] <- log1m(phi) + binomial_log(k[i], n, theta[i,1]);#
lp_parts[i,2] <- log(phi) + binomial_log(k[i], n, theta[i,2]);#
}#
}#
model {#
// Priors#
mubon ~ beta(1, 1); // can be removed#
mudiff ~ normal(0, 1 / sqrt(.5))T[0,]; // Constrained to be Positive#
// Relatively Uninformative Prior on Base Rate#
phi ~ beta(5, 5);#
for (i in 1:p)#
theta[i] ~ beta(alpha, beta);#
for (i in 1:p)#
increment_log_prob(log_sum_exp(lp_parts[i]));#
}#
generated quantities {#
int<lower=0,upper=1> z[p];#
for (i in 1:p) {#
vector[2] prob;#
prob <- softmax(lp_parts[i]);#
// Each Person Belongs to One of Two Latent Groups#
z[i] <- bernoulli_rng(prob[2]);#
}#
}"#
k <- c(45, 45, 44, 45, 44, 45, 45, 45, 45, 45, 30,#
20, 6, 44, 44, 27, 25, 17, 14, 27, 35, 30)#
p <- length(k) # number of people#
n <- 45 # number of questions#
data <- list(p=p, k=k, n=n) # To be passed on to Stan#
myinits <- list(#
list(phi=.5, mubon=.5, mudiff=1, lambdabon=400, lambdamal=50,#
theta=matrix(rep(.5, p * 2), p, 2)))#
# Parameters to be monitored#
parameters <- c("mubon", "lambdabon", "mumal", "lambdamal", "mudiff",#
"phi", "theta", "z")#
# The following command calls Stan with specific options.#
# For a detailed description type "?rstan".#
samples <- stan(model_code=model,#
data=data,#
init=myinits, # If not specified, gives random inits#
pars=parameters,#
iter=3000,#
chains=1,#
thin=1,#
# warmup = 100, # Stands for burn-in; Default = iter/2#
# seed = 123 # Setting seed; Default is random seed#
)#
# Now the values for the monitored parameters are in the "samples" object,#
# ready for inspection.#
print(samples, digits=3)
print(samples$z[,1])
print(extract(samples)$z[,1])
a <- 5:7
a
a[2:3]
a[2:3] <- a[1:2]
a
a[2:3] <- a
a
a <- 5:7
a[c(2,3,1)] <- a
a
a <- 5:7
a
a[c(2,3,1)]
a[c(2,3,1)] <- a
a
a <- 5:7
a[c(2,3,1)] <- c(10,20,30)
a
a <- 5:7
a[c(2,3,1)] <- a
a
a[(c(2,3,1))] <- 5:7
a
a <- 5:7
a[2] <- a[1]
a[3] <- a[2]
a[1] <- a[3]
a
a <- c(1,2,3)
a + c(10,10,10,10,10)
3250 / 4
library(rstan)
stan_demo()
quit()
1.02^10
2900/4
sample(1:10)
sample(100, 1:10, replace=true)
help(sample)
sample(10, replace=false)
sample(1)
sample(10)
sample(10, 1)
sample(10, 100, replace=TRUE)
a <- sample(10, 10000, replace=TRUE)
b <- matrix(a, 2, length(a)/2)
head(b)
for (i in 1:5000) b[,i] <- sort(b[,i])
b[,2]
b[,3]
sum <- 0
for (i in 1:5000) sum <- sum + b[2,i] - b[1,i]
sum / 5000
logit <- funtion(p) { log(p / (1 - p)) }
logit <- function(p) { log(p / (1 - p)) }
logit(0.1)
logit(0.2)
logit(0.5)
logit(0.35)
help(sample)
library(rstan)
help(rstan)
quit()
help(quantile)
prog <- "parameters { real theta; } model { theta ~ normal(0, 1); }"
theta_inits <- rnorm(1, 10, 1)
theta_inits
init_f <- function() { list(theta=theta_inits); }
init_f()
library(rstan)
fit <- stan(model_code=prog, init=init_f)
quit()
log(300)
exp(6)
library(rstan)
help(vb)
quit()
library(rstan)
help(rstan)
sqrt(1/1000)
1 /sqrt(.1)
1 / sqrt(.01)
library(rstan)
help(traceplot)
help(stanfit)
help(stanobject)
help(rstan)
x <- matrix(round(runif(i*k)), ncol =k)#
group <- c(rep(1, 7), rep(2, 4), rep(3, 3), rep(4, 5), rep(5,6))#
x[group==1,]
k = 4#
i = 25#
#
set.seed(123)#
#
x <- matrix(round(runif(i*k)), ncol =k)#
group <- c(rep(1, 7), rep(2, 4), rep(3, 3), rep(4, 5), rep(5,6))#
x[group==1,]
x
x <- matrix(1:6, 2, 3)
x
x[c(0,1,0), ]
x[c(0,1,1,1,1)]
x <- c(1,2,3,4)
x[c(1,1,2)]
x[c(0,1,0,1)]
x[c(1,2,3) < 2]
x
c(1,2,3) < 2
library(rstan)
prog <- "parameters { real<lower=1> y; } model { y ~ normal(2, 1); }"
fit <- stan(model_code=prog)
print(fit)
model_code <- '#
data {#
}#
transformed data {#
  real lo;#
  lo <- negative_infinity();#
  print("Finished transforming data.");#
}#
parameters {#
  real scale;#
}#
model {#
  print("Starting model.");#
  scale ~ normal(0, 1);#
  print("A");#
  {#
    real z_lo;#
    print("B");#
    z_lo <- lo * scale;#
  }#
}#
'
model_code
fit <- stan(model_code=model_code)
help(rnorm)
help(rt)
6.2 * 3.5 / 5.5
5.0 * 5.5 / 3.5
library(rstan)
fit <- stan(model_code = "parameters {real y; } model { y ~ normal(0, 1); }")
print(fit)
help(stan)
-c("a", "b")
a = 4
++a
-4
-a
a++
b
lapply(1:4, function(x) x^2)
xs <- lapply(1:4, function(x) x^2)
xs
xs("1")
xs[[1]]
xs <- lapply(1:4, function(x) c(x,x^2))
xs
inits <- function(chain) { return list(rho=runif(1,-1,1), sigma=rexp(1)) }
inits <- function(chain) list(rho=runif(1,-1,1), sigma=rexp(1))
inits(2)
inits(3)
inits <- function(chain) list(rho=runif(1,a,b), sigma=rexp(1))
inits(2)
a <- 3
inits(2)
quit()
library(rstan)
p(optimizing)
help(optimizing)
setwd("~/stan-dev/example-models/knitr/mle-params/")
library(rmarkdown)
render("mle-params.Rmd")
render("mle-params.Rmd")
render("mle-params.Rmd")
setSeed(123)
set.seed(123)
rbinom(10, 1, 0.3)
rbinom(10, 1, 0.3)
rbinom(10, 1, 0.3)
rbinom(10, 1, 0.3)
set.seed(123)
rbinom(10, 1, 0.3)
render("mle-params.Rmd")
render("mle-params.Rmd")
render("mle-params.Rmd")
render("mle-params.Rmd")
render("mle-params.Rmd")
render("mle-params.Rmd")
fit_mle_prob
sum(y) / N
y
sum(y)
N
sum(y) / N
help(sampling)
render("mle-params.Rmd")
render("mle-params.Rmd")
render("mle-params.Rmd")
fit_mle_logodds
fit_mle_log_odds$theta
fit_mle_logodds$theta
fit_mle_logodds$par
fit_mle_logodds$par$theta
fit_mle_logodds$par
fit_mle_logodds$par^2
fit_mle_logodds$par[[1]]
fit_mle_logodds$par[["theta"]]
fit_mle_logodds$par[["foo"]]
render("mle-params.Rmd")
fit_mle_logodds
render("mle-params.Rmd")
render("mle-params.Rmd")
render("mle-params.Rmd")
render("mle-params.Rmd")
render("mle-params.Rmd")
quit()
