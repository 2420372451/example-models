
R version 3.2.3 (2015-12-10) -- "Wooden Christmas-Tree"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.4.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> ## 6. Estimation of the size of a closed population
> ## 6.2. Generation and analysis of simulated data with data
> ## augmentation
> ## 6.3. Analysis of a real data set: model Mtbh for species richness estimation
> 
> library(rstan)
Loading required package: ggplot2
rstan (Version 2.8.1, packaged: 2015-11-18 17:18:35 UTC, GitRev: 05c3d0058b6a)
For execution on a local, multicore CPU with excess RAM we recommend calling
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
> rstan_options(auto_write = TRUE)
> options(mc.cores = parallel::detectCores())
> set.seed(1234)
> 
> ## Read in data
> ## "p610.txt" is available at
> ## http://www.vogelwarte.ch/de/projekte/publikationen/bpa/complete-code-and-data-files-of-the-book.html
> p610 <- read.table("p610.txt", header = TRUE)
> y <- p610[, 5:9]                        # Grab counts
> y[y > 1] <- 1                           # Counts to det-nondetections
> 
> ## Bundle data
> stan_data <- list(y = as.matrix(y), M = nrow(y), T = ncol(y))
> 
> ## Parameters monitored
> params <- c("N", "mean_p", "gamma", "sigma", "omega")
> 
> ## MCMC settings
> ni <- 30000
> nt <- 10
> nb <- 20000
> nc <- 4
> 
> ## Initial values
> inits <- lapply(1:nc, function(i) {
+     list(mean_p = runif(ncol(y), 0.3, 0.8),
+          sigma = runif(1, 0.1, 0.9),
+          omega = runif(1, 0.5, 0.8),
+          gamma = runif(1, -0.5, 5),
+          eps = rep(0, nrow(y)))})
> 
> ## Call Stan from R
> out <- stan("Mtbh.stan",
+             data = stan_data, init = inits, pars = params,
+             chains = nc, iter = ni, warmup = nb, thin = nt,
+             seed = 1,
+             control = list(adapt_delta = 0.95),
+             open_progress = FALSE)
starting worker pid=12137 on localhost:11648 at 19:32:41.292
starting worker pid=12145 on localhost:11648 at 19:32:41.421
starting worker pid=12153 on localhost:11648 at 19:32:41.554
starting worker pid=12161 on localhost:11648 at 19:32:41.688

SAMPLING FOR MODEL 'Mtbh' NOW (CHAIN 1).

Chain 1, Iteration:     1 / 30000 [  0%]  (Warmup)
SAMPLING FOR MODEL 'Mtbh' NOW (CHAIN 2).

Chain 2, Iteration:     1 / 30000 [  0%]  (Warmup)
SAMPLING FOR MODEL 'Mtbh' NOW (CHAIN 3).
[1] "Error : Rejecting initial value:"                        
[2] "  Gradient evaluated at the initial value is not finite."
[3] "  Stan can't start sampling from this initial value."    
error occurred during calling the sampler; sampling not done

SAMPLING FOR MODEL 'Mtbh' NOW (CHAIN 4).
[1] "Error : Rejecting initial value:"                        
[2] "  Gradient evaluated at the initial value is not finite."
[3] "  Stan can't start sampling from this initial value."    
error occurred during calling the sampler; sampling not done

Chain 2, Iteration:  3000 / 30000 [ 10%]  (Warmup)
Chain 1, Iteration:  3000 / 30000 [ 10%]  (Warmup)
Chain 1, Iteration:  6000 / 30000 [ 20%]  (Warmup)
Chain 2, Iteration:  6000 / 30000 [ 20%]  (Warmup)
Chain 1, Iteration:  9000 / 30000 [ 30%]  (Warmup)
Chain 2, Iteration:  9000 / 30000 [ 30%]  (Warmup)
Chain 1, Iteration: 12000 / 30000 [ 40%]  (Warmup)
Chain 2, Iteration: 12000 / 30000 [ 40%]  (Warmup)
Chain 1, Iteration: 15000 / 30000 [ 50%]  (Warmup)
Chain 2, Iteration: 15000 / 30000 [ 50%]  (Warmup)
Chain 1, Iteration: 18000 / 30000 [ 60%]  (Warmup)
Chain 2, Iteration: 18000 / 30000 [ 60%]  (Warmup)
Chain 1, Iteration: 20001 / 30000 [ 66%]  (Sampling)
Chain 2, Iteration: 20001 / 30000 [ 66%]  (Sampling)
Chain 1, Iteration: 23000 / 30000 [ 76%]  (Sampling)
Chain 2, Iteration: 23000 / 30000 [ 76%]  (Sampling)
Chain 1, Iteration: 26000 / 30000 [ 86%]  (Sampling)
Chain 2, Iteration: 26000 / 30000 [ 86%]  (Sampling)
Chain 1, Iteration: 29000 / 30000 [ 96%]  (Sampling)
Chain 1, Iteration: 30000 / 30000 [100%]  (Sampling)
#  Elapsed Time: 2678.55 seconds (Warm-up)
#                957.645 seconds (Sampling)
#                3636.2 seconds (Total)


Chain 2, Iteration: 29000 / 30000 [ 96%]  (Sampling)
Chain 2, Iteration: 30000 / 30000 [100%]  (Sampling)
#  Elapsed Time: 2732.94 seconds (Warm-up)
#                1241.49 seconds (Sampling)
#                3974.43 seconds (Total)

here are whatever error messages were returned
[[1]]
Stan model 'Mtbh' does not contain samples.

[[2]]
Stan model 'Mtbh' does not contain samples.

Warning messages:
1: In .local(object, ...) :
  some chains had errors; consider specifying chains = 1 to debug
2: There were 148 divergent transitions after warmup. Increasing adapt_delta above 0.95 may help. 
3: Examine the pairs() plot to diagnose sampling problems
 
> ## Note: There may be divergent transitions after warmup.
> ## The estimates may slightly differ from those by WinBUGS (p.160).
> 
> ## Summarize posteriors
> print(out, digits = 3)
Inference for Stan model: Mtbh.
2 chains, each with iter=30000; warmup=20000; thin=10; 
post-warmup draws per chain=1000, total post-warmup draws=2000.

            mean se_mean     sd    2.5%    25%    50%     75%   97.5% n_eff
N         43.629   0.220  7.443  34.000 38.000 42.000  47.000  62.000  1147
mean_p[1]  0.227   0.002  0.081   0.091  0.168  0.218   0.279   0.406  1623
mean_p[2]  0.282   0.002  0.096   0.120  0.215  0.273   0.344   0.488  1779
mean_p[3]  0.284   0.002  0.097   0.115  0.216  0.278   0.348   0.494  1822
mean_p[4]  0.210   0.002  0.082   0.075  0.153  0.200   0.259   0.389  1820
mean_p[5]  0.308   0.002  0.101   0.132  0.236  0.301   0.375   0.514  1855
gamma     -0.150   0.014  0.508  -1.153 -0.491 -0.139   0.202   0.787  1326
sigma      0.907   0.019  0.351   0.447  0.637  0.846   1.112   1.776   344
omega      0.300   0.002  0.065   0.198  0.256  0.292   0.336   0.449  1648
lp__      76.122   3.025 51.574 -24.968 38.731 75.649 116.627 166.643   291
           Rhat
N         1.001
mean_p[1] 1.000
mean_p[2] 1.001
mean_p[3] 0.999
mean_p[4] 1.000
mean_p[5] 1.001
gamma     1.000
sigma     1.006
omega     1.000
lp__      1.006

Samples were drawn using NUTS(diag_e) at Thu Dec 17 20:39:55 2015.
For each parameter, n_eff is a crude measure of effective sample size,
and Rhat is the potential scale reduction factor on split chains (at 
convergence, Rhat=1).
> 
> ## Model M0
> 
> ## Define parameters to be monitored
> params <- c("N", "p", "omega")
> 
> ## Call Stan from R
> out0 <- stan("M0.stan",
+              data = stan_data, pars = params,
+              chains = nc, iter = ni, warmup = nb, thin = nt,
+              seed = 1,
+              open_progress = FALSE)
starting worker pid=12345 on localhost:11648 at 20:39:56.252
starting worker pid=12353 on localhost:11648 at 20:39:56.469
starting worker pid=12361 on localhost:11648 at 20:39:56.693
starting worker pid=12369 on localhost:11648 at 20:39:56.917

SAMPLING FOR MODEL 'M0' NOW (CHAIN 1).

Chain 1, Iteration:     1 / 30000 [  0%]  (Warmup)
SAMPLING FOR MODEL 'M0' NOW (CHAIN 2).

Chain 2, Iteration:     1 / 30000 [  0%]  (Warmup)
SAMPLING FOR MODEL 'M0' NOW (CHAIN 3).

Chain 3, Iteration:     1 / 30000 [  0%]  (Warmup)
SAMPLING FOR MODEL 'M0' NOW (CHAIN 4).

Chain 4, Iteration:     1 / 30000 [  0%]  (Warmup)
Chain 1, Iteration:  3000 / 30000 [ 10%]  (Warmup)
Chain 2, Iteration:  3000 / 30000 [ 10%]  (Warmup)
Chain 3, Iteration:  3000 / 30000 [ 10%]  (Warmup)
Chain 4, Iteration:  3000 / 30000 [ 10%]  (Warmup)
Chain 1, Iteration:  6000 / 30000 [ 20%]  (Warmup)
Chain 2, Iteration:  6000 / 30000 [ 20%]  (Warmup)
Chain 3, Iteration:  6000 / 30000 [ 20%]  (Warmup)
Chain 4, Iteration:  6000 / 30000 [ 20%]  (Warmup)
Chain 1, Iteration:  9000 / 30000 [ 30%]  (Warmup)
Chain 2, Iteration:  9000 / 30000 [ 30%]  (Warmup)
Chain 3, Iteration:  9000 / 30000 [ 30%]  (Warmup)
Chain 4, Iteration:  9000 / 30000 [ 30%]  (Warmup)
Chain 1, Iteration: 12000 / 30000 [ 40%]  (Warmup)
Chain 2, Iteration: 12000 / 30000 [ 40%]  (Warmup)
Chain 3, Iteration: 12000 / 30000 [ 40%]  (Warmup)
Chain 4, Iteration: 12000 / 30000 [ 40%]  (Warmup)
Chain 1, Iteration: 15000 / 30000 [ 50%]  (Warmup)
Chain 2, Iteration: 15000 / 30000 [ 50%]  (Warmup)
Chain 3, Iteration: 15000 / 30000 [ 50%]  (Warmup)
Chain 4, Iteration: 15000 / 30000 [ 50%]  (Warmup)
Chain 1, Iteration: 18000 / 30000 [ 60%]  (Warmup)
Chain 2, Iteration: 18000 / 30000 [ 60%]  (Warmup)
Chain 3, Iteration: 18000 / 30000 [ 60%]  (Warmup)
Chain 1, Iteration: 20001 / 30000 [ 66%]  (Sampling)
Chain 2, Iteration: 20001 / 30000 [ 66%]  (Sampling)
Chain 4, Iteration: 18000 / 30000 [ 60%]  (Warmup)
Chain 3, Iteration: 20001 / 30000 [ 66%]  (Sampling)
Chain 4, Iteration: 20001 / 30000 [ 66%]  (Sampling)
Chain 1, Iteration: 23000 / 30000 [ 76%]  (Sampling)
Chain 2, Iteration: 23000 / 30000 [ 76%]  (Sampling)
Chain 3, Iteration: 23000 / 30000 [ 76%]  (Sampling)
Chain 4, Iteration: 23000 / 30000 [ 76%]  (Sampling)
Chain 1, Iteration: 26000 / 30000 [ 86%]  (Sampling)
Chain 2, Iteration: 26000 / 30000 [ 86%]  (Sampling)
Chain 3, Iteration: 26000 / 30000 [ 86%]  (Sampling)
Chain 4, Iteration: 26000 / 30000 [ 86%]  (Sampling)
Chain 1, Iteration: 29000 / 30000 [ 96%]  (Sampling)
Chain 1, Iteration: 30000 / 30000 [100%]  (Sampling)
#  Elapsed Time: 9.30904 seconds (Warm-up)
#                3.63959 seconds (Sampling)
#                12.9486 seconds (Total)


Chain 3, Iteration: 29000 / 30000 [ 96%]  (Sampling)
Chain 2, Iteration: 29000 / 30000 [ 96%]  (Sampling)
Chain 3, Iteration: 30000 / 30000 [100%]  (Sampling)
#  Elapsed Time: 8.93628 seconds (Warm-up)
#                3.59 seconds (Sampling)
#                12.5263 seconds (Total)


Chain 2, Iteration: 30000 / 30000 [100%]  (Sampling)
#  Elapsed Time: 9.13058 seconds (Warm-up)
#                3.97519 seconds (Sampling)
#                13.1058 seconds (Total)


Chain 4, Iteration: 29000 / 30000 [ 96%]  (Sampling)
Chain 4, Iteration: 30000 / 30000 [100%]  (Sampling)
#  Elapsed Time: 8.87865 seconds (Warm-up)
#                3.84091 seconds (Sampling)
#                12.7196 seconds (Total)

> 
> ## Summarize posteriors
> print(out0, digits = 3)
Inference for Stan model: M0.
4 chains, each with iter=30000; warmup=20000; thin=10; 
post-warmup draws per chain=1000, total post-warmup draws=4000.

          mean se_mean    sd     2.5%      25%      50%      75%    97.5% n_eff
N       37.776   0.061 3.747   32.000   35.000   37.000   40.000   46.000  3804
p        0.301   0.001 0.044    0.219    0.271    0.301    0.331    0.386  3899
omega    0.263   0.001 0.044    0.185    0.231    0.261    0.291    0.354  4000
lp__  -117.109   0.015 0.962 -119.562 -117.495 -116.831 -116.421 -116.154  3908
       Rhat
N     1.000
p     1.001
omega 1.000
lp__  1.000

Samples were drawn using NUTS(diag_e) at Thu Dec 17 20:40:16 2015.
For each parameter, n_eff is a crude measure of effective sample size,
and Rhat is the potential scale reduction factor on split chains (at 
convergence, Rhat=1).
> 
> proc.time()
    user   system  elapsed 
   2.190    0.289 4057.430 
